# [Mobile] : Dart

Documenta√ß√£o: https://cursos.alura.com.br/course/dart-variaveis-listas/task/102249
Status: DOING
Data de cria√ß√£o: December 25, 2023 7:38 AM
#cursos: Dart, Flutter, Mobile
Scholl: Alura
Reposit√≥rio: https://github.com/Andersonlimahw/dart-samples
Author / Teacher: Alura
Data de edi√ß√£o: February 4, 2024 12:27 PM
Data de conclus√£o: February 2, 2024
Progresso: ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê

# Anota√ß√µes

January 20, 2024 

Dart √© uma linguagem fortemente tipada  como o c#.

Com uma forte comunidade e suporte da Google. 

Implementa√ß√µes no repo: [https://github.com/Andersonlimahw/dart-samples?tab=readme-ov-file](https://github.com/Andersonlimahw/dart-samples?tab=readme-ov-file)

- [ ]  Exportar Conte√∫do para HTML

# M√≥dulo : 1

# Oque √© dart

Linguagem de programa√ß√£o com interoperabilidade com javascript por exemplo

√© orientada a objetos como C#, Java e Typescript.

# Pq Dart

Facilidade

Documenta√ß√£o 

Perfomance

Linguagem suportada pelo google e ascenss√£o no mercado 

Flutter √© um framework que utiliza dart ( front-end ), para desenvolvimento multi-plataforma.

Flame ( jogos ) 

Jaguar ( back-end)

![Untitled](%5BMobile%5D%20Dart%200f08d9bbf00140b18700e4cca658f2fe/Untitled.png)

Grandes empresas j√° utilizam como: 

- Google
- Ifood
- XP Inc

Criada em 2012 para destronar o javascript üòÅü§£

Fluuter foi lan√ßado em 2017

# Setup

[https://dart.dev/tools](https://dart.dev/tools)

cli:

[https://dart.dev/tools/dart-tool](https://dart.dev/tools/dart-tool)

## Listas

ver m√©todos de listas

[https://codeburst.io/top-10-array-utility-methods-you-should-know-dart-feb2648ee3a2](https://codeburst.io/top-10-array-utility-methods-you-should-know-dart-feb2648ee3a2)

Exemplo de class + lista

```dart
class Person {
  String name;
  int age;
  double salary;
  String site;

  Person(this.name, this.age, this.salary, this.site);

  @override
  String toString() => 'Name: $name Age: $age, Salary: $salary, Site: $site';
}
```

```dart
import 'package:initial_project/person.dart';

void main() {
	listsWithCustomClass();
}

void listsWithCustomClass() {
  Person person = Person('Anderson Lima', 30, 25000.00, 'https://lemon.dev.br');
  Person secondPerson =
      Person('Tony Lima', 20, 35000.00, 'https://tony.dev.br');
  List<Person> people = [person, secondPerson];
  print(people);
}
```

# M√≥dulo : 2

# Orienta√ß√£o a objetos

Paradigma √© uma esoolha, cada linguagem resolve um problema o Dart e C# utilizam orienta√ß√£o a objetos por exemplo.

J√° Javascript, typescript utilizam paradigma funcional.

√â como arroz e feij√£o, cada pessoa escolhe como comer da sua forma preferida.

Obejtos, classes, parentesco

![Untitled](%5BMobile%5D%20Dart%200f08d9bbf00140b18700e4cca658f2fe/Untitled%201.png)

Os paradigmas na programa√ß√£o s√£o como uma metodologia (um estilo) de estruturar e executar a linguagem que usa esse paradigma.

# Fun√ß√µes

Parametros 

void sample(String name) {

/// implementation

}

Parametros nomeados

void createPerson({

required String name,  // obrigat√≥rio

String? jobDescription // Opcional

String? city = ‚ÄúSP‚Äù // Opcional com Valor default

}) {

/// implementation

}

- **O que s√£o Fun√ß√µes:**
    - Vimos que fun√ß√£o √© um trecho de c√≥digo que, dadas algumas informa√ß√µes, faz uma a√ß√£o e pode devolver algum valor! Essa estrutura pode ser chamada v√°rias vezes no nosso c√≥digo, assim, ganharmos tempo na hora de escrever e corrigir nossa aplica√ß√£o. Falando de forma mais t√©cnica: fun√ß√µes s√£o a primeira forma de aplicar o conceito de modulariza√ß√£o, o que quer dizer isolar tarefas que v√£o ser repetidas, isso √© √∫til para criamos c√≥digos mais leg√≠veis, produtivos e eficientes.
- **Como criar Fun√ß√µes no Dart:**
    - Aprendemos que no Dart precisamos definir principalmente 4 aspectos da nossa fun√ß√£o: O tipo do retorno dela, seu nome, seus par√¢metros e seu c√≥digo interno.
- **Como configurar os Par√¢metros de uma Fun√ß√£o no Dart:**
    - Conversamos que existem os par√¢metros¬†**Posicionais Obrigat√≥rios**¬†e os¬†**Nomeados Opcionais**, e podemos dar um¬†**Valor Padr√£o**¬†para par√¢metros que poderiam ser nulos e, caso necess√°rio, podemos exigir que um par√¢metro seja entregue com o modificador¬†**required**.
- **Como funciona a ideia de Escopo:**
    - Por fim, vimos que desde que come√ßamos a modularizar nosso c√≥digo, temos que nos preocupar com a ideia de Escopo!¬†**Escopo**¬†√© como se fosse o territ√≥rio, o terreno da fun√ß√£o. Todo o c√≥digo que est√° dentro das chaves¬†`{...}`¬†faz parte do escopo dela, portanto, esse c√≥digo pertence e pode ser usado apenas por essa fun√ß√£o. Para recebermos informa√ß√µes externas √† fun√ß√£o, podemos usar os par√¢metros; para devolver uma informa√ß√£o para fora da fun√ß√£o, podemos usar o¬†`return`.

# Classes

Tem o objetivo de representar o mundo real, exemplo:

```kotlin
classFruta{
  String nome;
  String cor;

  Fruta(this.nome,this.cor);

  Fruta.nomeados({requiredthis.nome, requiredthis.cor});

  Fruta.minusculas(this.nome,this.cor){
    nome = nome.toLowerCase();
    cor = cor.toLowerCase();
  }
}
```

- **O que √© uma Classe:**
    - Classes s√£o os moldes que usamos para construir e representar coisas do mundo real. A partir desses moldes, podemos construir objetos espec√≠ficos e com caracter√≠sticas semelhantes. Falando de forma mais t√©cnica, criar uma classe √© uma forma modularizada e produtiva de escrever c√≥digo. Nelas, conseguimos representar as caracter√≠sticas de objetos atrav√©s das Propriedades e suas a√ß√µes atrav√©s dos m√©todos.
- **O que s√£o as Propriedades de uma Classe:**
    - Vimos que as propriedades de uma classe s√£o as caracter√≠sticas (informa√ß√µes) que desejamos registrar sobre os objetos que ser√£o gerados por essa classe. Aprendemos que algumas informa√ß√µes podem ser informadas j√° na cria√ß√£o da classe, mas outras precisar√£o vir externamente via Construtor.
- **O que √© o Construtor:**
    - Aprendemos tamb√©m que Construtores s√£o como aquele ‚Äúcheck-list‚Äù de passos a serem tomados antes de come√ßar uma viagem: √© o m√©todo que ser√° executado assim que um objeto dessa classe for criado. A sua principal tarefa normalmente √© inicializar as Propriedades, mas os Construtores tamb√©m podem executar a√ß√µes iniciais que a classe possa demandar.
- **O que s√£o M√©todos:**
    - Por fim, vimos que os M√©todos s√£o como fun√ß√µes dentro de uma classe e determinam os comportamentos que os objetos que ser√£o gerados por essa classe ter√£o.
    
    Heran√ßa √© uma das principais caracter√≠sticas do Paradigma de Orienta√ß√£o a Objetos, mas por qual motivo? Reflita por um breve instante.
    
    Bem, o motivo √© que a¬†**heran√ßa permite que classes compartilhem propriedades e m√©todos, atrav√©s de (literalmente) "heran√ßas"**. Pense que, em uma fam√≠lia, filhas e filhos podem herdar caracter√≠sticas e bens das suas m√£es e pais. J√° na programa√ß√£o, √© parecido: objetos podem herdar propriedades e m√©todos.
    
    O principal objetivo de usar heran√ßa √© reaproveitar c√≥digo. Isso √© feito usando o conceito de ‚Äúgeneraliza√ß√£o‚Äù e de ‚Äúespecifica√ß√£o‚Äù, onde a classe-m√£e (tamb√©m chamada de superclasse) possui, em geral, propriedades e m√©todos mais generalistas, enquanto as classes-filha (tamb√©m chamadas de subclasses) tornam as propriedades e m√©todos, recebidos pela superclasse, espec√≠ficos para seus objetivos.
    
    - **O que √© Heran√ßa:**
        - Quanto mais complexo fica nosso c√≥digo, mais classes precisamos criar, e fica muito evidente que muitos par√¢metros e m√©todos se repetem entre classes. Para facilitar a cria√ß√£o de c√≥digo e melhorar a performance da linguagem dart, temos a op√ß√£o de adicionar heran√ßa √†s nossas classes! A heran√ßa nada mais √© que a¬†**possibilidade de herdar dados e a√ß√µes de outras classes**¬†j√° criadas, a fim de facilitar o entendimento e organiza√ß√£o estrutural do nosso c√≥digo.
    - **Como utilizar Heran√ßa no Dart:**
        - A heran√ßa no dart √© feita de uma maneira simples: primeiro, devemos criar a classe que ser√° herdada, em seguida, criamos a classe que vai receber a heran√ßa. Depois, usamos a palavra¬†`extends`¬†para associar as duas Classes. Por fim, utilizamos o¬†`super`para pegar os dados herdados e utiliz√°-los na nossa Classe com heran√ßa.
    - **M√©todos compartilhados:**
        - Uma vez que temos m√∫ltiplas classes com heran√ßa, come√ßamos a notar que os m√©todos de cada classe se relacionam da mesma forma. Classes que possuem algum n√≠vel de parentesco vertical (M√£e -> Filha) podem utilizar os m√©todos herdados. Por√©m, o inverso n√£o √© rec√≠proco (Filha ->M√£e), nem mesmo o relacionamento horizontal (Irm√£ - Irm√£) permite a utiliza√ß√£o de m√©todos entre si.
    
    E, assim, encerramos a Aula 4! Lembrando sempre que se tiver d√∫vidas, n√£o deixe de aparecer l√° no f√≥rum!
    
    S√≥ falta mais uma aula para finalizarmos, hein! Vamos l√°?
    
    - **O que s√£o Classes Abstratas:**
        - As Classes abstratas (conhecidas em outras linguagens como Interface) s√£o como contratos pr√©-definidos. Elas s√£o muito usadas para dar um caminho definido para todas as classes que a implementam. Ao criar uma classe abstrata, fazemos os seus m√©todos sem nenhuma a√ß√£o, pois dessa forma, as a√ß√µes s√£o definidas apenas por aqueles que implementam a classe abstrata criada.
    - **Polimorfismo:**
        - Agora, j√° sabemos extender uma classe (M√£e/Filha) e j√° sabemos implementar uma classe abstrata (Contrato), e come√ßamos a notar que nem sempre os m√©todos herdados podem ser √∫teis a todo momento. Em alguns casos, precisamos alterar esses m√©todos sem comprometer outras classes, e para isso usamos a¬†`Sobrescrita`¬†com o comando¬†`@override`. O Polimorfismo nada mais √© que a habilidade das nossas classes de alterar um m√©todo recebido por heran√ßa.

# M√≥dulo : 3

# Sintaxe, semantica, enum e switch

- **O que √© Sintaxe:**
    - Vimos que toda linguagem, seja ela natural ou de programa√ß√£o, possui uma sintaxe, afinal, sintaxe √© um conjunto de regras que definem quais s√£o os termos dessa linguagem, como eles se relacionam e em que ordem s√£o esperados.
- **O que √© Sintaxe no Dart:**
    - Notamos que todas as estruturas que usamos no Dart at√© agora seguem uma sintaxe, e que, quando essa sintaxe n√£o √© respeitada, v√°rios erros ser√£o gerados, j√° que o Dart n√£o compreender√° o que estamos tentando construir.
- **O que s√£o¬†`Enums`:**
    - Aprendemos que¬†`Enums`¬†(Enumeradores) s√£o tipos de dados cujo os valores s√£o exatamente um conjunto finito de identificadores que escolhemos no momento em que estamos construindo o¬†`Enum`. Vimos que eles podem ser usados para tornar nossas compara√ß√µes mais leg√≠veis e eficientes.
- **O que s√£o Switchs:**
    - Por fim, conhecemos a Estrutura Condicional Switch-Case-Default, que, assim como a If-Else, serve para direcionarmos nosso c√≥digo a depender do resultado de uma opera√ß√£o booleana - no caso do¬†`Switch`, sempre uma compara√ß√£o feita usando como base um elemento definido no come√ßo da estrutura.

# Set, Iterables, Maps

Nessa aula, aprendemos conceitos importantes para voc√™ continuar nessa trilha de conhecimento. Os conceitos trabalhados aqui ser√£o revistos de forma bem mais pr√°tica nas pr√≥ximas aulas, por isso √© importante domin√°-los bem. Vamos fazer um resumo?

- **O que s√£o¬†`Sets`:**
    - Vimos que, em Dart,¬†`Sets`¬†s√£o¬†**cole√ß√µes**¬†que herdam de¬†`Iterable`, assim como as¬†`Lists`¬†e, para fins pr√°ticos, podem ser considerados um caso especial de¬†`List`¬†onde todas as entradas s√£o √∫nicas, ou seja, n√£o cont√™m entradas repetidas. Essa estrutura √© √∫til quando queremos armazenar valores √∫nicos em uma √∫nica vari√°vel sem considerar a ordem das entradas.
- **O que s√£o¬†*Iterables*:**
    - Vimos tamb√©m que¬†`Iterable`¬†√© uma cole√ß√£o de valores ou elementos que podem ser acessados sequencialmente. Vimos que essa¬†**classe √© abstrata**, ou seja, n√£o podemos instanciar objetos do tipo¬†*Iterable*, mas essa classe √© usada como base para as outras estruturas de cole√ß√£o:¬†`List`¬†e¬†`Sets`.
- **O que s√£o¬†`Maps`:**
    - Por fim, estudamos os¬†`Maps`, um tipo de cole√ß√£o extremamente √∫til em aplica√ß√µes reais como quando acessamos bancos de dados e trocamos informa√ß√µes com APIs. Nessa estrutura, sempre teremos um par contendo uma chave e um valor, onde essa chave d√° acesso √† leitura e modifica√ß√£o desse valor. √â por esse motivo que, em algumas linguagens, ela recebe o nome de ‚ÄúDicion√°rio‚Äù.

# Dynamics, var & static

- **Qual a diferen√ßa entre os termos Var e Dynamic:**
    - Aprendemos que¬†`dynamic`¬†√© um termo que indica quando um objeto pode alterar de tipagem em tempo de execu√ß√£o, ou seja, quando a aplica√ß√£o j√° estiver rodando. Isso √© uma caracter√≠stica um tanto quanto interessante e at√© perigosa, logo, √© necess√°rio saber trabalhar com ela para n√£o cometermos erros que podem quebrar nosso c√≥digo.
- **Qual a diferen√ßa entre um dado Est√°tico e um Din√¢mico:**
    - `Static`¬†√© um termo que indica quando um objeto deve manter seu valor independente da inst√¢ncia que atua sobre ela. Uma propriedade est√°tica faz parte de uma classe, ou seja, n√£o pode ser criada/instanciada por si s√≥.
- **O que s√£o Linguagens Est√°tica e Dinamicamente Tipadas:**
    - Vimos que algumas linguagens de programa√ß√£o s√£o¬†**din√¢micas**, o que significa que podemos alterar facilmente o tipo de um objeto sem problemas, mas isso faz com que o compilador/interpretador n√£o note quando um poss√≠vel erro pode ocorrer. Um exemplo de linguagem din√¢mica √©‚Ä¶¬†**Linguagens est√°ticas**, ou seja, que geralmente n√£o permitem a altera√ß√£o de tipos de objetos, t√™m a vantagem de verificarem se o c√≥digo apresenta algum erro antes de compilar/rodar o projeto. O Dart √© um exemplo de linguagem est√°tica!

# Private , Getter, Setter

Se voc√™ j√° estudou algumas outras linguagens de programa√ß√£o, deve se lembrar que muitas delas usam termos espec√≠ficos para determinar se uma propriedade ou vari√°vel vai ser p√∫blica (`public`), ou privada (`private`,¬†`protected`). Por√©m, como vimos no v√≠deo, o Dart usa apenas um¬†*underline*. Por que essa decis√£o?

Essa curiosidade √© muito bem-vinda, e muitas pessoas programadoras de Dart j√° tiveram ela, tanto que usaram ferramentas de comunidade (como as¬†*Issues*¬†no GitHub p√∫blico do Dart Core) para solicitar a mudan√ßa. Voc√™ pode acompanhar a discuss√£o¬†[nesse link](https://github.com/dart-lang/sdk/issues/33383). A postagem come√ßa com uma proposta do Dart aceitar tanto a sintaxe com underline quanto com as¬†*keywords*¬†(palavras-chave), e depois v√°rias pessoas programadoras argumentam a favor ou contra a mudan√ßa proposta.

Ent√£o, uma pessoa que desenvolve o Dart vem para dar uma explica√ß√£o: Ela diz que os termos n√£o s√£o usados, pois o¬†**Dart n√£o usa privacidade baseada em classe, e sim em arquivo/biblioteca**, e por uma s√©rie de raz√µes t√©cnicas, essas palavras-chave n√£o seriam condizentes. Ap√≥s dar a explica√ß√£o, ele arquiva o t√≥pico.

Mesmo com o t√≥pico arquivado, a discuss√£o continua e h√° pessoas a favor e contra a adi√ß√£o dos termos. Esse exemplo √© muito interessante para mostrar que Dart, como uma linguagem de c√≥digo aberto e com uma comunidade aquecida, d√° a possibilidade de discuss√£o e entendimento de certas nuances diretamente na fonte. Recomendamos bastante a leitura (em ingl√™s) na discuss√£o citada.

E voc√™: qual sua opini√£o sobre o assunto? J√° pensou em argumentos a favor ou contra o uso do underline? Se quiser, sinta-se √† vontade para dar sua opini√£o no f√≥rum ou discord!

- **O que √© Encapsulamento:**
    - √â not√°vel que existir√£o situa√ß√µes, tanto no mundo real, quanto na programa√ß√£o, em que precisamos¬†**gerenciar acessos**, isto √©, precisamos organizar quais pessoas podem ver ou alterar cada arquivo, ou trecho de c√≥digo. √â para isso que serve o conceito de encapsulamento e os conceitos de ‚Äúp√∫blico‚Äù e ‚Äúprivado‚Äù na programa√ß√£o.
- **O que s√£o Getters e Setters:**
    - Vimos que tornamos uma propriedade privada usando o¬†*underline*¬†antes do nome dela, por exemplo:¬†`_nome`. E, uma vez que essa propriedade se torna privada, usu√°rios da classe (e de inst√¢ncias da classe) n√£o podem acess√°-la e modific√°-la diretamente. Para fazer isso, precisamos criar m√©todos especiais. Os¬†*getters*¬†(em portugu√™s, ‚Äúpegadores‚Äù) v√£o conter o termo¬†`get`¬†e s√£o usados para¬†**leitura**¬†do valor, j√° os¬†*setters*¬†(em portugu√™s, ‚Äùdefinidores‚Äù) v√£o conter o termo¬†`set`¬†e s√£o usados para¬†**altera√ß√£o**¬†do valor.

# M√≥dulo : 4 Error handler

# Projeto base : Error handler

[https://dart.dev/language/error-handling](https://dart.dev/language/error-handling)

[https://api.dart.dev/stable/3.2.6/dart-core/Exception-class.html](https://api.dart.dev/stable/3.2.6/dart-core/Exception-class.html)

[https://api.dart.dev/stable/3.2.6/dart-core/Error-class.html](https://api.dart.dev/stable/3.2.6/dart-core/Error-class.html)

Excecoes: Situacoes que sabemos que acontecerao e nos planejamos

![Untitled](%5BMobile%5D%20Dart%200f08d9bbf00140b18700e4cca658f2fe/Untitled%202.png)

![Untitled](%5BMobile%5D%20Dart%200f08d9bbf00140b18700e4cca658f2fe/Untitled%203.png)

![Untitled](%5BMobile%5D%20Dart%200f08d9bbf00140b18700e4cca658f2fe/Untitled%204.png)

Samples

```dart
try {
  breedMoreLlamas();
} on OutOfLlamasException {
  // A specific exception
  buyMoreLlamas();
} on Exception catch (e) {
  // Anything else that is an exception
  print('Unknown exception: $e');
} catch (e) {
  // No specified type, handles all
  print('Something really unknown: $e');
}
```

StackTrace

```dart
try {
  // ¬∑¬∑¬∑
} on Exception catch (e) {
  print('Exception details:\n $e');
} catch (e, s) {
  print('Exception details:\n $e');
  print('Stack trace:\n $s');
}
```

Pilha de exce√ß√µes

Pilha se tira e adicione sempre de cima para baixo.

![Untitled](%5BMobile%5D%20Dart%200f08d9bbf00140b18700e4cca658f2fe/Untitled%205.png)

Dart devtools debugger
[https://dart.dev/tools/dart-devtools](https://dart.dev/tools/dart-devtools)

# Erros e exce√ß√µes

- **Qual a diferen√ßa entre Erros e Exce√ß√µes:**
    - Aprendemos que nem sempre nossas aplica√ß√µes seguir√£o pelo caminho perfeito, e que erros e situa√ß√µes excepcionais podem acontecer. Agora conseguimos diferenciar esses dois conceitos:
        - ‚ÄúErros‚Äù s√£o os problemas que n√£o temos total controle e n√£o fazem parte do fluxo esperado no nosso¬†*modelo de neg√≥cios*, quando estamos programando podemos at√© antecipar que erros v√£o acontecer, mas n√£o √© nossa fun√ß√£o trat√°-los em tempo de execu√ß√£o.
        - ‚ÄúExce√ß√µes‚Äù s√£o as situa√ß√µes excepcionais que fogem do ‚Äúcaminho feliz‚Äù previsto no fluxo do nosso¬†*modelo de neg√≥cios*. Essas situa√ß√µes sim, n√≥s devemos antever, tratar e resolver da melhor forma poss√≠vel para nossa pessoa usu√°ria.
- **O que √© a Pilha de Execu√ß√£o:**
    - Vimos tamb√©m que um conceito importante para compreens√£o das exce√ß√µes √© o da Pilha de Execu√ß√£o, que √© uma forma de representar como o Sistema Operacional prioriza a leitura do c√≥digo que n√≥s escrevemos na nossa aplica√ß√£o.
- **O que √© o Depurador e o Modo de Depura√ß√£o:**
    - Aprendemos, por fim, que nos nossos Ambientes de Desenvolvimento (IDEs) n√£o temos apenas a op√ß√£o de ‚ÄúRodar‚Äù o nosso c√≥digo, temos tamb√©m a op√ß√£o de ‚ÄúDepurar‚Äù (Debug). A op√ß√£o Debug roda nosso c√≥digo em Modo de Depura√ß√£o, abrindo para gente uma nova aba chamada ‚ÄúDepurador‚Äù. Nela temos a vis√£o de v√°rias novas ferramentas que permitem uma an√°lise linha a linha do nosso c√≥digo, coisa que n√£o seria poss√≠vel no modo de ‚ÄúRodar‚Äù que estamos acostumados.

# Asserts

[https://dart.dev/tools/linter-rules/prefer_asserts_with_message](https://dart.dev/tools/linter-rules/prefer_asserts_with_message)

asserts executam apenas em ambiente de desenvolvimento.

Exemplo valida√ß√£o de classes

```dart
class Account {
  String id;
  String name;
  double balance;
  bool isAuthenticated;

  Account({
    required this.id,
    required this.name,
    required this.balance,
    required this.isAuthenticated,
  })  : assert(name.trim().isNotEmpty, 'Nome n√£o pode ser uma string vazia'),
        assert(balance > 0, 'Balance deve ser maior do que zero'),
        assert(id.isNotEmpty, 'Id √© obrigat√≥rio'),
        assert(isAuthenticated, 'Usu√°rio deve estar autenticado');

  editBalance({required value}) {
    balance = balance + value;
  }

  @override
  String toString() {
    String message =
        'Account => Id: $id name: $name, balance: $balance, isAuthenticated: $isAuthenticated';
    print(message);
    return message;
  }
}
```

# Para saber mais

Finalizamos nosso conte√∫do a respeito de Exce√ß√µes, e seguindo com nosso √≠mpeto de incentivar a leitura da documenta√ß√£o, deixamos uma lista de recomenda√ß√µes para leitura (toda em ingl√™s) a respeito do tema:

- [Language Tour | Dart - Exceptions](https://dart.dev/guides/language/language-tour#exceptions)¬†- O ‚ÄúLanguage Tour‚Äù √© um documento que re√∫ne o m√≠nimo que voc√™ precisa saber sobre os mais importantes assuntos da linguagem. E no link que disponibilizamos voc√™ encontra a sess√£o que fala a respeito de Exce√ß√µes;
- [Language Tour | Dart - Assert](https://dart.dev/guides/language/language-tour#assert)¬†- Texto do ‚ÄúLanguage Tour‚Äù sobre os Asserts;
- [Dart-Core | Exception Class](https://api.dart.dev/stable/2.17.3/dart-core/Exception-class.html)¬†- Documenta√ß√£o da classe¬†`Exception`¬†presente na linguagem, onde voc√™ encontra uma documenta√ß√£o mais t√©cnica que explica quest√µes como Heran√ßas, Interfaces, Propriedades, Contrutores e M√©todos da classe, que no caso √© a Exception;
- [Dart-Core | Erro Class](https://api.dart.dev/stable/2.17.3/dart-core/Error-class.html)¬†- Documenta√ß√£o da classe¬†`Error`¬†presente na linguagem.

Lembre-se que a leitura da documenta√ß√£o tamb√©m √© um passo muito importante para voc√™ aprender e compreender o processo como um todo. Por isso, n√£o deixe de faz√™-la.

# Resumo error handler

**Como lan√ßar uma Exce√ß√£o:**

- Aprendemos que com a palavra-chave¬†`throw`¬†podemos lan√ßar uma exce√ß√£o, ou seja, parar a execu√ß√£o do c√≥digo naquela sub-rotina (fun√ß√£o) e enviar um objeto-exce√ß√£o para quem estiver abaixo na Pilha de Execu√ß√£o. Se essa exce√ß√£o lan√ßada passar por todos os quadros da pilha sem ser tratado, ela terminar√° a execu√ß√£o do c√≥digo com uma sa√≠da de insucesso. E abordamos que o Dart permite enviarmos qualquer objeto no¬†`throw`, mas que c√≥digos de qualidade, principalmente em ambiente de produ√ß√£o, lan√ßam apenas objetos de tipos que implementam¬†`Exception`¬†ou¬†`Error`.

**Como criar uma exce√ß√£o personalizada:**

- Aprendemos que o processo de criar uma exce√ß√£o personalizada consiste basicamente em criar uma classe que implementa a classe abstrata¬†`Exception`, e que, uma vez criada, podemos lan√ßar nossas exce√ß√µes com o throw e captur√°-las com a estrutura try-on-cath-finally.

**Como criar e usar propriedades e m√©todos para nossas Exce√ß√µes Personalizadas:**

- Tamb√©m aprendemos que, como uma classe, podemos criar membros (propriedades e m√©todos) para uma Exce√ß√£o, que estar√£o dispon√≠veis para acesso ao capturarmos nossa Exce√ß√£o com o¬†`catch`.

**O que √© e como usar o Assert:**

- Por fim, aprendemos que podemos usar o comando¬†`assert`¬†para fazer verifica√ß√µes apenas em ambiente de desenvolvimento que tenha o comando de terminal¬†`-enable-asserts`¬†ativado. Essa ferramenta √© √∫til para fazer testes com o AssertionError, que para a execu√ß√£o do nosso programa, mas s√≥ apenas em tempo de desenvolvimento, n√£o afetando o c√≥digo que chegar√° √† pessoa usu√°ria.

**Conclu√≠mos a nossa terceira aula!**

Parab√©ns! Voc√™ j√° avan√ßou bastante e j√° estamos caminhando para o fim do nosso curso. Volte nessa aula sempre que achar necess√°rio para refor√ßar e se tiver d√∫vidas, n√£o deixe de aparecer l√° no f√≥rum para conversar com a gente e com outros cursistas.

# Null safety

Null no dart √© uma classe que n√£o pode ser instanciada

[https://dart.dev/null-safety](https://dart.dev/null-safety)

- **O que √© um Nulo:**
    - Aprendemos que no Dart, o Nulo √© um tipo n√£o instanci√°vel e representa a aus√™ncia de valor. Aprendemos tamb√©m que no passado, o¬†`null`¬†era um subtipo de todos os tipos, mas desde a implementa√ß√£o do Null Safety na linguagem, o¬†`Null`¬†passou a ser um tipo a parte de todos, podendo agora uma vari√°vel ou propriedade receber¬†**ou**¬†apenas valores n√£o nulos,¬†**ou**¬†tanto valores nulos quanto n√£o nulos.
- **O problema que o Null Safety resolve:**
    - Aprendemos que o Null Safety resolve o problema das Refer√™ncias Nulas, ou seja, de tentarmos acessar membros de vari√°veis que est√£o com valores nulos, evitando assim erros em tempo de execu√ß√£o.
- **Como lidar com nulos de uma forma segura:**
    - Por fim, aprendemos que existem algumas formas seguras de se lidar com nulos e a principal delas √© testando se a vari√°vel cont√©m ou n√£o um valor nulo. Esse teste com¬†`if-else`¬†garante, em tempo de execu√ß√£o, que a vari√°vel n√£o ser√° nula. Tamb√©m podemos usar a chamada segura, ou Safe Call, utilizando a¬†`?`¬†quando queremos tentar acessar um membro de uma classe, e n√£o uma vari√°vel local.

# Asyncs

[https://dart.dev/codelabs/async-await](https://dart.dev/codelabs/async-await)

# SingleThread

Um thread de cada vez, de forma encadeada.

Isolates e LoopEvetns

No Dart utilizamos apenas um Isolate, por√©m √© poss√≠vel utilizar mais de um Isolate

um isolate √© um espa√ßo de m√©moria

![Untitled](%5BMobile%5D%20Dart%200f08d9bbf00140b18700e4cca658f2fe/Untitled%206.png)

Multithread

![Untitled](%5BMobile%5D%20Dart%200f08d9bbf00140b18700e4cca658f2fe/Untitled%207.png)

Artigo para entender melhor Isolates:
[https://blog.codemagic.io/understanding-flutter-isolates/](https://blog.codemagic.io/understanding-flutter-isolates/)

# Async

Exemplos pr√°ticos

Acesso ao banco de dados

Acesso a API‚Äôs

## Future

```dart
Future<void> fetchUserOrder() {
// Imagine that this function is fetching user info from another service or database.
return Future.delayed(const Duration(seconds: 2), () => print('Large Latte'));
}

void main() {
  fetchUserOrder();
  print('Fetching user order...');
}
```

```dart
main() {
  Future myFuture = Future(() {
    print('Backing to the future.');
    return 21;
  }).then((value) => print('Future value: $value'));

  Future.delayed(Duration(seconds: 2));

  Future<int> myFunctionFuture() async {
    Future.delayed(Duration(seconds: 5));
    return await myFuture;
  }

  myFunctionFuture();

  print('Done main!');
	}
```

## Resumo

- **Saber o que significa¬†*Single Thread*:**
    - Vimos que o Dart √© uma linguagem¬†*Single Thread*, ou seja, que realiza uma tarefa por vez.
- **Identificar o que s√£o¬†*Isolates*:**
    - Espa√ßos de mem√≥ria com loops, dedicados para realizar tarefas no computador - por exemplo, abrir uma nova tela.
- **Saber como funcionam os Loop de Eventos:**
    - Funcionalidades que buscam por tarefas na pilha de execu√ß√£o do programa e individualmente fazem o processo de levar as tarefas at√© os espa√ßos de mem√≥ria onde ser√£o processadas.
- **Compreender a import√¢ncia do Assincronismo:**
    - T√©cnica que separa tarefas que precisam de um tempo de espera, a fim de tornar eficiente a execu√ß√£o de tarefas r√°pidas, enquanto esperamos por tarefas lentas (que esperam informa√ß√£o de fora, lugar de onde n√£o temos controle).
- **Entender o funcionamento e alterar o KakoBot:**
    - Vimos o c√≥digo padr√£o do nosso projeto, e como ele funciona al√©m de olhar passo a passo os m√©todos que comp√µem a l√≥gica por tr√°s do nosso bot pessoal.

## Streams

[https://dart.dev/tutorials/language/streams](https://dart.dev/tutorials/language/streams)

[https://dart.dev/tutorials/language/streams#process-stream-methods](https://dart.dev/tutorials/language/streams#process-stream-methods)

Sample:

Creating

```dart
class BotClock {
  Future clock({required int timeInSeconds}) {
    return Future.delayed(Duration(seconds: timeInSeconds));
  }

  //Creating:
  Stream lemonStream(int intervalIsSeconds, int maxCount) async* {
    int index = 1;
    while (index < maxCount) {
      print(
          'Counting: $index, interval: $intervalIsSeconds, maxCount: $maxCount');
      await Future.delayed(Duration(seconds: intervalIsSeconds));
      yield index++; // Yield significa captura.
    }
    print('The stream is finished!');
  }
}
```

Listening:

```dart
var customStream = BotClock().lemonStream(1, 10);
var subscriber = customStream.listen((event) {
  print('Stream is running to $event');
}, onDone: () {
  print('Stream is done!');
  shouldRun = false;
});
print(subscriber);
```

Resumo:

- **Criar¬†`Streams`:**
    - Vimos como criar uma¬†`Stream`¬†, um objeto que recebe informa√ß√µes por um longo per√≠odo de tempo, onde essas informa√ß√µes v√™m em intervalos! Normalmente as Streams j√° nos s√£o dadas por entidades fora do nosso c√≥digo, mas, por n√£o estarmos conectados com um Banco de Dados/Servidor Externo/API, decidimos criar nossa pr√≥pria¬†`Stream`.
- **Criar um¬†`Subscriber`:**
    - Para escutar as informa√ß√µes que v√™m da nossa¬†`Stream`, precisamos criar um objeto do tipo¬†`StreamSubscriber`¬†que tem a habilidade de ouvir a¬†`Stream`¬†por meio do m√©todo¬†`listen()`, al√©m de poder manipular as informa√ß√µes, tratar erros e muito mais.
- **Pausar, reiniciar e cancelar uma¬†`Stream`:**
    - Descobrimos o poder de manipular nossa subscri√ß√£o na¬†`Stream`¬†decidindo quando paus√°-la para impedir novas informa√ß√µes de vir, em seguida descobrimos como reinici√°-la para retomar o fluxo de informa√ß√µes e at√© cancel√°-la, para n√£o mais gastar recursos!